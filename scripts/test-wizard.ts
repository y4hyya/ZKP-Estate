#!/usr/bin/env tsx

import { ethers } from "ethers";
import { writeFileSync, mkdirSync, existsSync } from "fs";
import { join } from "path";
import { execSync } from "child_process";

// Mock data for testing
const mockPolicy = {
  minAge: 18,
  incomeMul: 3,
  rentWei: 1000, // 1000 units (simplified for testing)
  needCleanRec: true,
  deadline: Math.floor(Date.now() / 1000) + 86400, // 24 hours from now
  owner: "0x1234567890123456789012345678901234567890",
  policyHash: "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
};

// Test inputs
const testInputs = {
  walletAddress: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
  age: 25,
  monthlyIncome: 5.0,
  criminalFlag: 0,
  policyId: 1,
};

function addressToBigInt(address: string): string {
  // Use a simpler approach - just use the last 8 characters as a number
  const hex = address.slice(-8);
  return BigInt('0x' + hex).toString();
}

function generateSalt(): string {
  // Generate a smaller random number
  const randomBytes = ethers.randomBytes(8);
  return BigInt('0x' + ethers.hexlify(randomBytes).slice(2)).toString();
}

function computeNullifier(userId: string, policyId: number, salt: string): string {
  const userIdBigInt = BigInt(userId);
  const policyIdBigInt = BigInt(policyId);
  const saltBigInt = BigInt(salt);
  
  // Use modulo to keep within field bounds
  const fieldModulus = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
  return ((userIdBigInt + policyIdBigInt + saltBigInt) % fieldModulus).toString();
}

function generateProverToml(inputs: any): string {
  return `# Generated by input-wizard.ts
# Public inputs (exposed to verifier)
min_age = ${inputs.min_age}
income_mul = ${inputs.income_mul}
rent_wei = ${inputs.rent_wei}
need_clean_rec = ${inputs.need_clean_rec}
policy_id = ${inputs.policy_id}
nullifier = "${inputs.nullifier}"

# Private inputs (witness only)
age = ${inputs.age}
income = ${inputs.income}
criminal_flag = ${inputs.criminal_flag}
user_id = "${inputs.user_id}"
salt = "${inputs.salt}"
`;
}

async function testWizard() {
  console.log('üßô‚Äç‚ôÇÔ∏è ZKP-Estate Input Wizard Test');
  console.log('='.repeat(40));
  
  // Convert inputs
  const incomeWei = testInputs.monthlyIncome * 1000; // Convert to same units as rent
  const userId = addressToBigInt(testInputs.walletAddress);
  const salt = generateSalt();
  const nullifier = computeNullifier(userId, testInputs.policyId, salt);
  
  // Prepare prover inputs
  const inputs = {
    min_age: mockPolicy.minAge,
    income_mul: mockPolicy.incomeMul,
    rent_wei: mockPolicy.rentWei,
    need_clean_rec: mockPolicy.needCleanRec ? 1 : 0,
    policy_id: testInputs.policyId,
    nullifier: nullifier,
    age: testInputs.age,
    income: incomeWei,
    criminal_flag: testInputs.criminalFlag,
    user_id: userId,
    salt: salt,
  };
  
  // Validate inputs
  const warnings: string[] = [];
  
  if (inputs.age < mockPolicy.minAge) {
    warnings.push(`‚ö†Ô∏è  Age ${inputs.age} is below minimum required age ${mockPolicy.minAge}`);
  }
  
  const requiredIncome = mockPolicy.incomeMul * mockPolicy.rentWei;
  if (inputs.income < requiredIncome) {
    warnings.push(`‚ö†Ô∏è  Income ${inputs.income} is below required ${requiredIncome} (${mockPolicy.incomeMul}x rent)`);
  }
  
  if (mockPolicy.needCleanRec && inputs.criminal_flag === 1) {
    warnings.push(`‚ö†Ô∏è  Policy requires clean record but criminal_flag is set to 1`);
  }
  
  // Generate Prover.toml
  const proverToml = generateProverToml(inputs);
  const proverPath = join(process.cwd(), 'circuits', 'eligibility', 'Prover.toml');
  writeFileSync(proverPath, proverToml);
  console.log(`üìù Prover.toml generated at ${proverPath}`);
  
  // Test nargo execute
  try {
    console.log('üîÆ Testing nargo execute...');
    const circuitsDir = join(process.cwd(), 'circuits', 'eligibility');
    const output = execSync('nargo execute', { 
      cwd: circuitsDir,
      encoding: 'utf8'
    });
    console.log('‚úÖ nargo execute successful');
  } catch (error) {
    console.error('‚ùå nargo execute failed:', error);
  }
  
  // Print summary
  console.log('\nüìä Summary:');
  console.log('='.repeat(50));
  console.log(`Policy ID: ${inputs.policy_id}`);
  console.log(`Min Age: ${mockPolicy.minAge} | User Age: ${inputs.age}`);
  console.log(`Income Multiplier: ${mockPolicy.incomeMul}x`);
  console.log(`Rent: ${mockPolicy.rentWei} units`);
  console.log(`Required Income: ${requiredIncome} units`);
  console.log(`User Income: ${inputs.income} units`);
  console.log(`Clean Record Required: ${mockPolicy.needCleanRec ? 'Yes' : 'No'}`);
  console.log(`User Criminal Record: ${inputs.criminal_flag ? 'Yes' : 'No'}`);
  console.log(`Policy Deadline: ${new Date(mockPolicy.deadline * 1000).toISOString()}`);
  
  if (warnings.length > 0) {
    console.log('\n‚ö†Ô∏è  Warnings:');
    warnings.forEach(warning => console.log(warning));
  } else {
    console.log('\n‚úÖ All validations passed!');
  }
  
  console.log('\nüîç Generated Prover.toml:');
  console.log(proverToml);
}

testWizard().catch(console.error);
